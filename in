((lambda (x) (+ x 1)) 2)
((lambda (x y) (+ x y)) 2 3)
(* 3 3)
((lambda (f x) (f x)) (lambda (x) (* x x)) 3)
(if (eq? 2 3) 1 2)
(define f (lambda (x) (if (eq? x 0) 0 (+ x (f (- x 1))))))
(f 100)
(define Y (lambda (f) ((lambda (x) (f (lambda (v) ((x x) v)))) (lambda (x) (f (lambda (v) ((x x) v)))))))
(define fact (Y (lambda (f) (lambda (n) (if (= n 0) 1 (* n (f (- n 1))))))))
(fact 10)
(define (sum n) (if (= n 0) 0 (+ n (f (- n 1)))))
(sum 100)
(cons 1 (cons 2 ()))
(cons (cons (cons 1 2) (cons 3 4)) (cons 2 (cons 3 4)))
(list 1 2 3 4 5)
(define (map f l) (if (eq? l ()) () (cons (f (car l)) (map f (cdr l)))))
(map (lambda (x) (* x x)) (list 1 2 3 4 5))
(define (filter f l) (if (eq? l ()) () (let ((a (car l))(b (cdr l))) (if (f a) (cons a (filter f b)) (filter f b)))))
(filter (lambda (x) (= 0 (mod x 2))) (list 1 2 3 4 5 6 7 8))
(define (append a b) (if (eq? a ()) b (cons (car a) (append (cdr a) b))))
(define (flat l) (if (eq? () l) () (append (car l) (flat (cdr l)))))
(define (flatmap f l) (flat (map f l)))
(define (perm l) (if (eq? () l) (list ()) (flat (map (lambda (x) (map (lambda (l) (cons x l)) (perm (filter (lambda (y) (not (= y x))) l)))) l))))
(define (length l) (if (eq? l ()) 0 (+ 1 (length (cdr l)))))
(define (split l) (define (helper a b r) (if (= 0 r) (list a b) (helper (cdr a) (cons (car a) b) (- r 1)))) (let ((len (length l))) (helper l () (/ len 2))))
(define (merge l1 l2) (if (null? l1) l2 (if (null? l2) l1 (let ((a (car l1)) (b (car l2))) (if (< a b) (cons a (merge (cdr l1) l2)) (cons b (merge l1 (cdr l2))))))))
(merge (list 1 4 5) (list 2 3 6))
(define (mergeSort l) (if (< (length l) 2) l (let ((ls (split l))) (merge (mergeSort (car ls)) (mergeSort (car (cdr ls)))))))
(mergeSort (list 4 5 1 2 7 8 3 0 6 9))
